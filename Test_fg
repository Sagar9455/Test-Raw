2025-06-19 08:48:54,315 [DEBUG] Rx: <71E> (08) [p]	 037f2e33aaaaaaaa
2025-06-19 08:48:54,317 [DEBUG] Received 3 bytes : [7f2e33]
2025-06-19 08:48:54,320 [DEBUG] Received response from server
2025-06-19 08:48:54,324 [WARNING] WriteDataByIdentifier service execution returned a negative response SecurityAccessDenied (0x33)
2025-06-19 08:48:54,327 [WARNING] TC_036 ECUSoftwareUnit1IVDDataIdentifier(2E F1 C1) -> FAIL - NRC: 0x33
2025-06-19 08:48:54,330 [DEBUG] Stopping CanStack
2025-06-19 08:48:54,334 [DEBUG] Main thread is exiting
2025-06-19 08:48:54,369 [DEBUG] CanStack Stopped
2025-06-19 08:48:54,371 [INFO] Connection closed
2025-06-19 08:48:56,478 [INFO] CAN logging stopped: /home/mobase/Pld/udsoncan/output/can_logs/CANLog_ECU_Info_20250619_084707.asc
[CANLogger] Log file saved to: /home/mobase/Pld/udsoncan/output/can_logs/CANLog_ECU_Info_20250619_084707.asc
2025-06-19 08:48:57,980 [INFO] âœ… Log file found: /home/mobase/Pld/udsoncan/output/can_logs/CANLog_ECU_Info_20250619_084707.asc
Log file found: /home/mobase/Pld/udsoncan/output/can_logs/CANLog_ECU_Info_20250619_084707.asc
Traceback (most recent call last):
  File "/home/mobase/Pld/udsoncan/input/application/main.py", line 263, in <module>
    main()
  File "/home/mobase/Pld/udsoncan/input/application/main.py", line 260, in main
    app.main_menu()
  File "/home/mobase/Pld/udsoncan/input/application/main.py", line 167, in main_menu
    self.uds.run_testcase(self.oled)
  File "/home/mobase/Pld/udsoncan/input/drivers/uds_client.py", line 463, in run_testcase
    generate_report(
  File "/home/mobase/Pld/udsoncan/input/drivers/report_generator.py", line 353, in generate_report
    generate_html_report(
  File "/home/mobase/Pld/udsoncan/input/drivers/report_generator.py", line 290, in generate_html_report
    for key, value in ecu_info_data.items():
                      ^^^^^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'items'


####


    def run_testcase(self, oled):
        if not self.check_memory(oled):
            return

        self.start_logging(log_name_suffix="Testcase")
        ecu_info_data = self.get_ecu_information(oled=None)
        grouped_cases = load_testcases()
        self.context = {}
        
        for tc_id, steps in grouped_cases.items():
            print("\n")
            logging.info(f"Running Test Case: {tc_id}")
                            
            for step in steps:
                tc_id, step_desc, service, subfunc, expected, *rest = step

                # Get addressing mode from step or default to physical
                addressing = rest[0].strip().lower() if rest else "physical"
                try:
                    self.switch_mode(addressing)
                   
                    
                    with Client(self.active_conn["conn"], request_timeout=2, config=self.active_conn["client_config"]) as client:
                                
                        logging.info(f"Switched to {addressing} mode for TC: {tc_id} Step: {step_desc}")
                        service_int = int(service, 16)
                        subfunc_int = int(subfunc, 16)
                        expected_bytes = [int(b, 16) for b in expected.strip().split()]
                        write_data_dict = self.active_conn["client_config"].get('write_data', {})
                  
                        logging.info(f"Loaded write data:{list(write_data_dict.keys())}")
                        
                        logging.info(f"{tc_id} - {step_desc}: SID={service}, Sub={subfunc}, Expected={expected_bytes}")

                        response=None
                        if service_int == 0x10:
                            response = client.change_session(subfunc_int)
                        elif service_int == 0x11:
                            response = client.ecu_reset(subfunc_int)
                        elif service_int == 0x22:
                            response = client.read_data_by_identifier(subfunc_int)
                        elif service_int == 0x2E:  # WriteDataByIdentifier
                            data_to_write = write_data_dict.get(subfunc_int)
                            if data_to_write is None:
                                raise ValueError(f"No write data configured for DID {hex(subfunc_int)}")
                            response = client.write_data_by_identifier(subfunc_int, data_to_write)
                        elif service_int == 0x19:  # ReadDTCInformation
                            response = client.read_dtc_information(subfunc_int,status_mask=0xFF)
                            
                        elif service_int == 0x14:  # ClearDiagnosticInformation
                            group_of_dtc = subfunc_int
                            
                            
                            
                             status = "Fail"
                        failure_reason = "-"
                        if response.positive:
                            actual = list(response.original_payload)
                            if actual[:len(expected_bytes)] == expected_bytes:
                                status = "Pass"
                                logging.info(f"{tc_id} {step_desc}-> PASS")
                            else:
                                failure_reason = f"Expected {expected_bytes}, got {actual}"
                                logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                        else:
                            failure_reason = f"NRC: {hex(response.code)}"
                            logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                except Exception as e:
                    status = "Fail"
                    failure_reason = str(e)
                    logging.error(f"{tc_id} {step_desc} -> EXCEPTION - {failure_reason}")

                delay_key=service.upper()
                delay=float(self.step_delays.get(delay_key,self.default_delay))
                oled.display_centered_text(f"{tc_id}\n{step_desc[:20]}\n{status}")
                time.sleep(delay)

        self.stop_logging()
        time.sleep(1.5)

        full_log_path = self.can_logger.get_log_path() or "N/A"
        can_log_file = os.path.basename(full_log_path)
