def get_ecu_information(self, oled=None, logging_enable=True):

    testcase_file_path = self.get_testcase_file_path()
    if logging_enable:
        self.start_logging(log_name_suffix="ECU_Info")

    ecu_info = {}
    session_default = int(self.uds_config["default_session"], 16)
    session_extended = int(self.uds_config["extended_session"], 16)

    grouped_cases = load_testcases(testcase_file_path)
    time.sleep(0.5)

    def normalize_hex_string(val):
        return val.lower().replace("0x", "").strip()

    with Client(self.active_conn["conn"], request_timeout=2, config=self.client_config) as client:
        try:
            client.change_session(session_default)
            time.sleep(0.2)
            client.change_session(session_extended)
            time.sleep(0.2)

        except Exception as e:
            if oled:
                oled.display_centered_text(f"Session Error:\n{str(e)}")
            logging.error(f"Session change failed: {e}")
            return

        for tc_id, steps in grouped_cases.items():
            if not tc_id.startswith("ECU_INFO"):
                continue

            logging.info(f"[ECU Info] Processing {tc_id}")

            for step in steps:
                logging.debug(f"[ECU Info] Step={step}")

                try:
                    tc_id, step_desc, service, subfunc, expected, *rest = step

                    service_clean = normalize_hex_string(service)
                    subfunc_clean = normalize_hex_string(subfunc)

                    try:
                        service_int = int(service_clean, 16)
                        subfunc_int = int(subfunc_clean, 16)
                    except ValueError as ve:
                        logging.error(f"[ECU Info] Invalid service or subfunc in {tc_id} step '{step_desc}': {ve}")
                        continue

                    # Build raw request based on service
                    if service_int == 0x22:
                        # ReadDataByIdentifier → 0x22 DID-HI DID-LO
                        did_hi = (subfunc_int >> 8) & 0xFF
                        did_lo = subfunc_int & 0xFF
                        raw_request = bytes([service_int, did_hi, did_lo])
                    else:
                        # Other service → service subfunction
                        raw_request = bytes([service_int, subfunc_int])

                    logging.info(f"[ECU Info] Sending raw request: {raw_request.hex()}")

                    client.conn.send(raw_request)
                    response = client.conn.wait_frame(timeout=2)

                    raw_payload = list(response)
                    logging.debug(f"[ECU Info] Received raw payload: {raw_payload}")

                    # Basic check for positive response
                    if len(raw_payload) < 1:
                        raise Exception(f"Empty response!")

                    expected_positive_sid = service_int + 0x40
                    if raw_payload[0] != expected_positive_sid:
                        raise Exception(f"Unexpected response SID: got {raw_payload[0]:02X}, expected {expected_positive_sid:02X}")

                    # For 0x22 check DID match:
                    if service_int == 0x22:
                        if raw_payload[1] != did_hi or raw_payload[2] != did_lo:
                            raise Exception(f"DID mismatch: expected {did_hi:02X} {did_lo:02X}, got {raw_payload[1]:02X} {raw_payload[2]:02X}")

                        raw_data = raw_payload[3:]
                    else:
                        raw_data = raw_payload[1:]

                    hex_str = ' '.join(f"{b:02X}" for b in raw_data)
                    ecu_info[step_desc] = hex_str

                    if oled:
                        oled.display_centered_text(f"{step_desc}\n{hex_str}")
                        time.sleep(2)

                    logging.info(f"[ECU Info] {step_desc} ({subfunc}) = {hex_str}")

                except Exception as e:
                    error_msg = str(e)[:40]
                    ecu_info[step_desc] = f"Error: {error_msg}"

                    if oled:
                        oled.display_centered_text(f"{step_desc}\nError: {error_msg}")

                    logging.error(f"[ECU Info] {step_desc} - Exception: {e}")

                time.sleep(0.1)

    if logging_enable:
        self.stop_logging()

    return ecu_info
