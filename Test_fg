def get_ecu_information(self, oled=None):
    self.start_logging(log_name_suffix="ECU_Info")
    ecu_info = {}

    session_default = int(self.uds_config["default_session"], 16)
    session_extended = int(self.uds_config["extended_session"], 16)
    grouped_cases = load_testcases()

    def normalize_hex_string(val):
        return val.lower().replace("0x", "").strip()

    with Client(self.active_conn["conn"], request_timeout=2, config=self.client_config) as client:
        try:
            client.change_session(session_default)
            time.sleep(0.2)
            client.change_session(session_extended)
            time.sleep(0.2)
        except Exception as e:
            if oled:
                oled.display_centered_text(f"Session Error:\n{str(e)}")
            logging.error(f"Session change failed: {e}")
            self.stop_logging()
            return

        # Go through all RDxxx
        for tc_id, steps in grouped_cases.items():
            if not tc_id.startswith("RD"):
                continue

            logging.info(f"[ECU Info] Processing {tc_id}")

            for step in steps:
                logging.debug(f"[ECU Info] Step={step}")

                try:
                    tc_id, step_desc, service, subfunc, expected, *rest = step

                    service_clean = normalize_hex_string(service)
                    subfunc_clean = normalize_hex_string(subfunc)

                    if service_clean != "22":
                        continue

                    try:
                        did = int(subfunc_clean, 16)
                    except ValueError as ve:
                        logging.error(f"[ECU Info] Invalid subfunc '{subfunc}' in {tc_id} step '{step_desc}': {ve}")
                        continue

                    response = client.read_data_by_identifier(did)
                    if response.positive:
                        values = response.service_data.values[did]
                        if isinstance(values, (bytes, bytearray)):
                            hex_str = ' '.join(f"{b:02X}" for b in values)
                        elif isinstance(values, str):
                            hex_str = values
                        else:
                            hex_str = str(values)

                        ecu_info[step_desc] = hex_str

                        if oled:
                            oled.display_centered_text(f"{step_desc}\n{hex_str}")

                        logging.info(f"[ECU Info] {step_desc} ({subfunc}) = {hex_str}")

                    else:
                        nrc = hex(response.code)
                        ecu_info[step_desc] = f"NRC: {nrc}"

                        if oled:
                            oled.display_centered_text(f"{step_desc}\nNRC: {nrc}")

                        logging.warning(f"[ECU Info] {step_desc} - NRC: {nrc}")

                except Exception as e:
                    error_msg = str(e)[:40]
                    ecu_info[step_desc] = f"Error: {error_msg}"

                    if oled:
                        oled.display_centered_text(f"{step_desc}\nError: {error_msg}")

                    logging.error(f"[ECU Info] {step_desc} - Exception: {e}")

                time.sleep(0.1)

    self.stop_logging()
###

2025-06-19 08:29:23,516 [INFO] Captured sequence: [12, 20]
2025-06-19 08:29:25,102 [DEBUG] can config: {'channel': 'can0', 'interface': 'socketcan'}
2025-06-19 08:29:25,103 [INFO] Created a socket
2025-06-19 08:29:25,104 [DEBUG] Binding socket to channel=can0
2025-06-19 08:29:25,104 [DEBUG] Bound socket.
2025-06-19 08:29:25,106 [INFO] CAN logging started: /home/mobase/Pld/udsoncan/output/can_logs/CANLog_ECU_Info_20250619_082925.asc
2025-06-19 08:29:25,108 [DEBUG] Starting CanStack
2025-06-19 08:29:25,109 [DEBUG] Main thread has started
2025-06-19 08:29:25,110 [DEBUG] Relay thread has started
2025-06-19 08:29:25,111 [INFO] Connection opened
2025-06-19 08:29:25,112 [INFO] DiagnosticSessionControl<0x10> - Switching session to defaultSession (0x01)
2025-06-19 08:29:25,113 [DEBUG] Sending request to server
2025-06-19 08:29:25,114 [DEBUG] Sending 2 bytes : [1001]
2025-06-19 08:29:25,115 [DEBUG] Enqueuing a SendRequest for 2 bytes and TAT=Physical
2025-06-19 08:29:25,116 [DEBUG] Waiting for server response
2025-06-19 08:29:25,117 [DEBUG] Tx: <716> (08) [ ]	 0210010000000000
2025-06-19 08:29:25,118 [DEBUG] We've been asked to write a message to the bus
2025-06-19 08:29:25,118 [DEBUG] sending: Timestamp:        0.000000        ID: 0716    S Rx                DL:  8    02 10 01 00 00 00 00 00
2025-06-19 08:29:25,144 [DEBUG] Rx: <71E> (08) [p]	 065001003201f4aa
2025-06-19 08:29:25,146 [DEBUG] Received 6 bytes : [5001003201f4]
2025-06-19 08:29:25,149 [DEBUG] Received response from server
2025-06-19 08:29:25,150 [INFO] Received positive response for service DiagnosticSessionControl (0x10) from server.
2025-06-19 08:29:25,353 [INFO] DiagnosticSessionControl<0x10> - Switching session to extendedDiagnosticSession (0x03)
2025-06-19 08:29:25,354 [DEBUG] Sending request to server
2025-06-19 08:29:25,354 [DEBUG] Sending 2 bytes : [1003]
2025-06-19 08:29:25,355 [DEBUG] Enqueuing a SendRequest for 2 bytes and TAT=Physical
2025-06-19 08:29:25,355 [DEBUG] Waiting for server response
2025-06-19 08:29:25,356 [DEBUG] Tx: <716> (08) [ ]	 0210030000000000
2025-06-19 08:29:25,357 [DEBUG] We've been asked to write a message to the bus
2025-06-19 08:29:25,358 [DEBUG] sending: Timestamp:        0.000000        ID: 0716    S Rx                DL:  8    02 10 03 00 00 00 00 00
2025-06-19 08:29:25,383 [DEBUG] Rx: <71E> (08) [p]	 065003003201f4aa
2025-06-19 08:29:25,384 [DEBUG] Received 6 bytes : [5003003201f4]
2025-06-19 08:29:25,386 [DEBUG] Received response from server
2025-06-19 08:29:25,387 [INFO] Received positive response for service DiagnosticSessionControl (0x10) from server.
2025-06-19 08:29:25,588 [INFO] [ECU Info] Processing RD
2025-06-19 08:29:25,591 [DEBUG] Stopping CanStack
2025-06-19 08:29:25,592 [DEBUG] Main thread is exiting
2025-06-19 08:29:25,636 [DEBUG] CanStack Stopped
2025-06-19 08:29:25,637 [INFO] Connection closed
2025-06-19 08:29:25,730 [ERROR] [CANLogger] Error during stop: I/O operation on closed file.


####
def get_ecu_information(self, oled=None):
        
        self.start_logging(log_name_suffix="ECU_Info")
        ecu_info = {}
        session_default = int(self.uds_config["default_session"], 16)
        session_extended = int(self.uds_config["extended_session"], 16)
        grouped_cases = load_testcases()
        with Client(self.active_conn["conn"], request_timeout=2, config=self.client_config) as client:
            try:
                client.change_session(session_default)
                time.sleep(0.2)
                client.change_session(session_extended)
                time.sleep(0.2)
            except Exception as e:
                oled.display_centered_text(f"Session Error:\n{str(e)}")
                logging.error(f"Session change failed: {e}")
                self.stop_logging()
                return

            # Go through all RDxxx
            for tc_id, steps in grouped_cases.items():
                if not tc_id.startswith("RD"):
                    continue
            
                logging.info(f"[ECU Info] Processing {tc_id}")
            
                for step in steps:
                    try:
                        tc_id, step_desc, service, subfunc, expected, *rest = step
            
                        if service != "22":
                            continue
            
                        try:
                                did = int(subfunc, 16)
                                
                        except ValueError as ve:
                               logging.error(f"[ECU Info] Invalid subfunc '{subfunc}' in {tc_id} step '{step_desc}': {ve}")
                               continue
                               
                        response = client.read_data_by_identifier(did)
                        if response.positive:
                            values = response.service_data.values[did]
                            if isinstance(values, (bytes, bytearray)):
                                hex_str = ' '.join(f"{b:02X}" for b in values)
                            elif isinstance(values, str):
                                hex_str = values
                            else:
                                hex_str = str(values)
            
                            ecu_info[step_desc] = hex_str
            
                            if oled:
                                oled.display_centered_text(f"{step_desc}\n{hex_str}")
            
                            logging.info(f"[ECU Info] {step_desc} ({subfunc}) = {hex_str}")
            
                        else:
                            nrc = hex(response.code)
                            ecu_info[step_desc] = f"NRC: {nrc}"
            
                            if oled:
                                oled.display_centered_text(f"{step_desc}\nNRC: {nrc}")
            
                            logging.warning(f"[ECU Info] {step_desc} - NRC: {nrc}")
            
                    except Exception as e:
                        error_msg = str(e)[:40]
                        ecu_info[step_desc] = f"Error: {error_msg}"
            
                        if oled:
                            oled.display_centered_text(f"{step_desc}\nError: {error_msg}")
            
                        logging.error(f"[ECU Info] {step_desc} - Exception: {e}")
            
                    time.sleep(3)

             

        self.stop_logging()

    def run_testcase(self, oled):
        if not self.check_memory(oled):
            return

        self.start_logging(log_name_suffix="Testcase")
        ecu_info_data = self.get_ecu_information(oled=None)
        grouped_cases = load_testcases()
        self.context = {}
        
        for tc_id, steps in grouped_cases.items():
            print("\n")
            logging.info(f"Running Test Case: {tc_id}")
                            
            for step in steps:
                tc_id, step_desc, service, subfunc, expected, *rest = step

                # Get addressing mode from step or default to physical
                addressing = rest[0].strip().lower() if rest else "physical"
                try:
                    self.switch_mode(addressing)
                   
                    
                    with Client(self.active_conn["conn"], request_timeout=2, config=self.active_conn["client_config"]) as client:
                                
                        logging.info(f"Switched to {addressing} mode for TC: {tc_id} Step: {step_desc}")
                        service_int = int(service, 16)
                        subfunc_int = int(subfunc, 16)
                        expected_bytes = [int(b, 16) for b in expected.strip().split()]
                        write_data_dict = self.active_conn["client_config"].get('write_data', {})
                  
                        logging.info(f"Loaded write data:{list(write_data_dict.keys())}")
                        
                        logging.info(f"{tc_id} - {step_desc}: SID={service}, Sub={subfunc}, Expected={expected_bytes}")

                        response=None
                        if service_int == 0x10:
                            response = client.change_session(subfunc_int)
                            
                            
                            
                            
 ###'
 #TC_ID-0 , Sub Service Description , Service ID , Sub service ID , Positive response data,addressing
RD , S/W Version  , 0x22 , 0xF1DD , 0x62,physical
RD , B-CAN Version , 0x22 , 0xF100 , 0x62,physical
RD , ManufacturingDate(22 F1 8B) , 0x22 , 0xF18B , 0x62,physical
RD , ECU_Serial Number , 0x22 , 0xF18C , 0x62,physical
RD , H/W Version , 0x22 , 0xF193 , 0x62,physical
TC_001 , DefaultSession(10 01) , 0x10 , 0x01 , 0x50, physical
TC_002 , Extended Session (10 03) , 0x10 , 0x03 , 0x50 ,physical
TC_003 , TesterPresent(3E 00) , 0x3E , 0x00 , 0x7E ,functional
TC_004 , S/W Version Dataidentifier(22 F1 DD) , 0x22 , 0xF1DD , 0x62,physical
TC_005 , BodyCANDataBaseVersionNumBErDataIdentifier(22 F1 00) , 0x22 , 0xF100 , 0x62,physical
TC_006 , VehicleManufacturerSparePartNumBErDataIdentifier(22 F1 87) , 0x22 , 0xF187 , 0x62,physical
TC_007 , ECUManufacturingDateDataIdentifier(22 F1 8B) , 0x22 , 0xF18B , 0x62,physical
TC_008 , ECUSerialNumberDataIdentifier (22 F1 8C), 0x22 , 0xF18C , 0x62,physical
TC_009 , SystemSupplierECUHardwareVersionNumberDataIdentifier(22 F1 91), 0x22 , 0xF191 , 0x62,physical
TC_010 , SystemSupplierECUHardwareVersionNumberDataIdentifier(22 F1 93) , 0x22 , 0xF193 , 0x62,physical
TC_011 , SystemSupplierECUSoftwareVersionNumbe DataIdentifier(22 F1 95) , 0x22 , 0xF195 , 0x62,physical
TC_012 , SoftwareVersionHKMCVehicleManufactureDataIdentifier(22 F1 A0) , 0x22 , 0xF1A0 , 0x62,physical
TC_013 , DTC setting ON (85 01), 0x85 , 0x01 , 0xC5, functional
TC_014 , DTC setting OFF(85 02) , 0x85 , 0x02 , 0xC5,functional
TC_015 , EnableRxAndEnableTx(28 00) , 0x28 , 0x00 , 0x68,functional
TC_016 , EnableRxAndDisableTx(28 01) , 0x28 , 0x01 , 0x68,functional
TC_017, DisableRxAndEnableTx(28 02) , 0x28 , 0x02 , 0x68,functional
TC_018 , DisableRxAndDisableTx(28 03) , 0x28 , 0x03 , 0x68,functional
TC_019 , Hard Reset(11 01) , 0x11 , 0x01 , 0x51,physical                           
