###2
def parse_asc_file(asc_file_path, allowed_tx_ids, allowed_rx_ids):
    messages_by_tc = defaultdict(list)
    start_ts = None
    end_ts = None

    current_tc_id = None
    current_desc = None
    current_request = None
    awaiting_multiframe = False
    skip_next_fc = False
    rx_multi_response_pending = False
    rx_multi_response_first = None

    allowed_tx_ids = set(f"{id:X}" for id in allowed_tx_ids)
    allowed_rx_ids = set(f"{id:X}" for id in allowed_rx_ids)

    with open(asc_file_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line or not re.match(r"^\d+\.\d+", line):
                continue

            msg = parse_line(line)
            if not msg:
                continue

            can_id = msg["can_id"].upper()

            # --- Tx Message ---
            if msg["direction"] == "Tx" and can_id in allowed_tx_ids:
                data_bytes = msg["data_bytes"]

                # New PC/TC with description:
                if msg.get("tc_id") and msg.get("desc"):
                    current_tc_id = msg["tc_id"]
                    current_desc = msg["desc"]

                if not current_tc_id:
                    continue  # skip Tx if no known TC

                # New request
                current_request = {
                    "timestamp": msg["timestamp"],
                    "can_id": msg["can_id"],
                    "direction": msg["direction"],
                    "data_bytes": msg["data_bytes"],
                    "desc": current_desc or "",
                    "tc_id": current_tc_id or "",
                    "expected_resp": msg.get("expected_resp", ""),
                    "status": "Pending",
                    "response": None,
                    "failure_reason": ""
                }

                messages_by_tc[current_tc_id].append(current_request)

                # Multi-frame?
                if data_bytes and data_bytes[0].upper() == "10":
                    awaiting_multiframe = True
                    skip_next_fc = True
                else:
                    awaiting_multiframe = False

            # --- Rx Message ---
            elif msg["direction"] == "Rx" and can_id in allowed_rx_ids:
                data_bytes = msg["data_bytes"]

                # Flow control
                if skip_next_fc and data_bytes and data_bytes[0].upper() == "30":
                    skip_next_fc = False
                    continue

                # Multi-frame response start
                if data_bytes and data_bytes[0].upper() == "10":
                    rx_multi_response_first = msg
                    rx_multi_response_pending = True
                    continue

                # Multi-frame continuation
                if rx_multi_response_pending and data_bytes and data_bytes[0].upper() == "21":
                    combined_bytes = rx_multi_response_first["data_bytes"][:7] + data_bytes[1:]
                    rx_msg = {
                        "timestamp": rx_multi_response_first["timestamp"],
                        "can_id": rx_multi_response_first["can_id"],
                        "direction": rx_multi_response_first["direction"],
                        "data_bytes": combined_bytes
                    }

                    if current_request:
                        status, reason = get_status(combined_bytes, current_request.get("expected_resp", ""))
                        current_request["response"] = rx_msg
                        current_request["status"] = status
                        current_request["failure_reason"] = reason

                        # timestamps
                        req_ts = current_request["timestamp"]
                        res_ts = rx_msg["timestamp"]
                        if start_ts is None or req_ts < start_ts:
                            start_ts = req_ts
                        if end_ts is None or res_ts > end_ts:
                            end_ts = res_ts

                        current_request = None

                    rx_multi_response_pending = False
                    rx_multi_response_first = None
                    continue

                # Single-frame response
                if current_request and not rx_multi_response_pending:
                    status, reason = get_status(data_bytes, current_request.get("expected_resp", ""))
                    current_request["response"] = msg
                    current_request["status"] = status
                    current_request["failure_reason"] = reason

                    # timestamps
                    req_ts = current_request["timestamp"]
                    res_ts = msg["timestamp"]
                    if start_ts is None or req_ts < start_ts:
                        start_ts = req_ts
                    if end_ts is None or res_ts > end_ts:
                        end_ts = res_ts

                    current_request = None

    return messages_by_tc, start_ts or 0, end_ts or 0



##1
def parse_asc_file(asc_file_path, allowed_tx_ids, allowed_rx_ids):
    messages_by_tc = defaultdict(list)
    current_request = None
    start_ts = None
    end_ts = None
    awaiting_multiframe = False
    skip_next_fc = False
    rx_multi_response_pending = False
    rx_multi_response_first = None

    allowed_tx_ids = set(f"{id:X}" for id in allowed_tx_ids)
    allowed_rx_ids = set(f"{id:X}" for id in allowed_rx_ids)

    with open(asc_file_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line or not re.match(r"^\d+\.\d+", line):
                continue

            msg = parse_line(line)
            if not msg:
                continue

            can_id = msg["can_id"].upper()

            # Process Tx messages
            if msg["direction"] == "Tx" and can_id in allowed_tx_ids:
                data_bytes = msg["data_bytes"]

                # Multi-frame request
                if data_bytes and data_bytes[0].upper() == "10":
                    current_request = msg
                    awaiting_multiframe = True
                    skip_next_fc = True
                else:
                    # Single frame
                    if msg.get("tc_id") and msg.get("desc"):
                        current_request = msg
                        awaiting_multiframe = False

            # Process Rx messages
            elif msg["direction"] == "Rx" and can_id in allowed_rx_ids:
                data_bytes = msg["data_bytes"]

                # Flow Control frame
                if skip_next_fc and data_bytes and data_bytes[0].upper() == "30":
                    skip_next_fc = False
                    continue

                # Multi-frame response - first frame
                if data_bytes and data_bytes[0].upper() == "10":
                    rx_multi_response_first = msg
                    rx_multi_response_pending = True
                    continue

                # Multi-frame response - consecutive frame
                if rx_multi_response_pending and data_bytes and data_bytes[0].upper() == "21":
                    combined_bytes = rx_multi_response_first["data_bytes"][:7] + data_bytes[1:]

                    # Skip ResponsePending
                    if combined_bytes[0].upper() == "7F" and combined_bytes[2].upper() == "78":
                        logging.debug("Multi-frame ResponsePending (0x78), waiting...")
                        continue

                    rx_msg = {
                        "timestamp": rx_multi_response_first["timestamp"],
                        "can_id": rx_multi_response_first["can_id"],
                        "direction": rx_multi_response_first["direction"],
                        "data_bytes": combined_bytes
                    }

                    if current_request:
                        status, reason = get_status(combined_bytes, current_request.get("expected_resp", ""))
                        current_request["response"] = rx_msg
                        current_request["status"] = status
                        current_request["failure_reason"] = reason

                        if current_request["tc_id"] and not current_request["tc_id"].startswith("ECU_INFO"):
                            messages_by_tc[current_request["tc_id"]].append(current_request)

                        req_ts = current_request["timestamp"]
                        res_ts = rx_msg["timestamp"]
                        if start_ts is None or req_ts < start_ts:
                            start_ts = req_ts
                        if end_ts is None or res_ts > end_ts:
                            end_ts = res_ts

                        current_request = None

                    rx_multi_response_pending = False
                    rx_multi_response_first = None
                    continue

                # Single frame response
                if current_request and not rx_multi_response_pending:
                    # Skip ResponsePending
                    if data_bytes[0].upper() == "7F" and data_bytes[2].upper() == "78":
                        logging.debug("Single frame ResponsePending (0x78), waiting...")
                        continue

                    status, reason = get_status(data_bytes, current_request.get("expected_resp", ""))
                    current_request["response"] = msg
                    current_request["status"] = status
                    current_request["failure_reason"] = reason

                    if current_request["tc_id"] and not current_request["tc_id"].startswith("ECU_INFO"):
                        messages_by_tc[current_request["tc_id"]].append(current_request)

                    req_ts = current_request["timestamp"]
                    res_ts = msg["timestamp"]
                    if start_ts is None or req_ts < start_ts:
                        start_ts = req_ts
                    if end_ts is None or res_ts > end_ts:
                        end_ts = res_ts

                    current_request = None

    return messages_by_tc, start_ts or 0, end_ts or 0


###ECU info

def get_ecu_information(self, oled=None, logging_enable=True):
    testcase_file_path = self.get_testcase_file_path()
    if logging_enable:
        self.start_logging(log_name_suffix="ECU_Info")

    ecu_info = {}
    session_default = int(self.uds_config["default_session"], 16)
    session_extended = int(self.uds_config["extended_session"], 16)

    grouped_cases = load_testcases(testcase_file_path)
    time.sleep(0.5)

    def normalize_hex_string(val):
        return val.lower().replace("0x", "").strip()

    with Client(self.active_conn["conn"], request_timeout=2, config=self.client_config) as client:
        try:
            client.change_session(session_default)
            time.sleep(0.2)
            client.change_session(session_extended)
            time.sleep(0.2)

        except Exception as e:
            if oled:
                oled.display_centered_text(f"Session Error:\n{str(e)}")
            logging.error(f"Session change failed: {e}")
            return

        for tc_id, steps in grouped_cases.items():
            if not tc_id.startswith("ECU_INFO"):
                continue

            logging.info(f"[ECU Info] Processing {tc_id}")

            for step in steps:
                logging.debug(f"[ECU Info] Step={step}")

                try:
                    tc_id, step_desc, service, subfunc, expected, *rest = step

                    service_clean = normalize_hex_string(service)
                    subfunc_clean = normalize_hex_string(subfunc)

                    try:
                        service_int = int(service_clean, 16)
                        did = int(subfunc_clean, 16)
                    except ValueError as ve:
                        logging.error(f"[ECU Info] Invalid service or subfunc '{subfunc}' in {tc_id} step '{step_desc}': {ve}")
                        continue

                    # RAW request
                    if service_int == 0x22:  # ReadDataByIdentifier
                        did_hi = (did >> 8) & 0xFF
                        did_lo = did & 0xFF
                        raw_request = bytes([0x22, did_hi, did_lo])
                    else:
                        raw_request = bytes([service_int, did])

                    logging.info(f"[ECU Info] Sending raw request: {raw_request.hex()}")

                    client.conn.send(raw_request)
                    response = client.conn.wait_frame(timeout=2)

                    raw_payload = list(response)
                    logging.debug(f"[ECU Info] Received raw payload: {raw_payload}")

                    # Validate response
                    if service_int == 0x22:
                        if raw_payload[0] != 0x62:
                            raise Exception(f"Unexpected response: {raw_payload}")
                        if raw_payload[1] != did_hi or raw_payload[2] != did_lo:
                            raise Exception(f"DID mismatch: {raw_payload}")

                        raw_data = raw_payload[3:]
                    else:
                        raw_data = raw_payload[1:]

                    # Build HEX string
                    hex_str = ' '.join(f"{b:02X}" for b in raw_data)

                    # Try ASCII conversion if printable
                    try:
                        ascii_str = bytes(raw_data).decode("ascii").strip()
                        if all(32 <= ord(c) <= 126 for c in ascii_str):
                            display_value = ascii_str
                        else:
                            display_value = hex_str
                    except:
                        display_value = hex_str

                    # Store value
                    ecu_info[step_desc] = display_value

                    if oled:
                        oled.display_centered_text(f"{step_desc}\n{display_value}")
                        time.sleep(2)

                    logging.info(f"[ECU Info] {step_desc} ({subfunc}) = {display_value}")

                except Exception as e:
                    error_msg = str(e)[:40]
                    ecu_info[step_desc] = f"Error: {error_msg}"

                    if oled:
                        oled.display_centered_text(f"{step_desc}\nError: {error_msg}")

                    logging.error(f"[ECU Info] {step_desc} - Exception: {e}")

                time.sleep(0.1)

    if logging_enable:
        self.stop_logging()
    return ecu_info
