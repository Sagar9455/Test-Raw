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9999999
      import csv
from collections import defaultdict

grouped_cases = defaultdict(list)

def load_testcases(file_path):
    grouped_cases.clear()
    try:
        with open(file_path, "r") as f:
            reader = csv.reader(f)
            header = next(reader)  # Skip header

            for row in reader:
                if not row or len(row) < 5:
                    continue  # Skip empty or malformed lines

                tc_id = row[0].strip()
                step_desc = row[1].strip()
                service_id = row[2].strip()
                subfunction_or_did = row[3].strip()
                expected_response = row[4].strip()
                write_data = row[5].strip() if len(row) > 5 else ""
                addressing = row[6].strip().lower() if len(row) > 6 else "physical"

                grouped_cases[tc_id].append((
                    tc_id,
                    step_desc,
                    service_id,
                    subfunction_or_did,
                    expected_response,
                    write_data,
                    addressing
                ))

        return grouped_cases

    except Exception as e:
        print(f"Error parsing testcases: {e}")
        return {}



def run_testcase(self, oled):

    if not self.check_memory(oled):
        return

    testcase_file_path = self.get_testcase_file_path()
    self.start_logging(log_name_suffix="Testcase")
    ecu_info_data = self.get_ecu_information(oled=None, logging_enable=False)
    grouped_cases = load_testcases(testcase_file_path)
    self.context = {}

    for tc_id, steps in grouped_cases.items():

        # Skip only ECU_Info, run all others
        if tc_id.strip().upper() == "ECU_INFO":
            logging.info(f"Skipping test case: {tc_id}")
            continue

        print("\n")
        logging.info(f"Running Test Case: {tc_id}")

        for step in steps:
            tc_id, step_desc, service, subfunc, expected, write_data, addressing = step


            # Get addressing mode from step or default to physical
            addressing = rest[0].strip().lower() if rest else "physical"

            try:
                self.switch_mode(addressing)

                with Client(self.active_conn["conn"], request_timeout=2, config=self.active_conn["client_config"]) as client:

                    logging.info(f"Switched to {addressing} mode for TC: {tc_id} Step: {step_desc}")

                    service_int = int(service, 16)
                    subfunc_int = int(subfunc, 16)
                    expected_bytes = [int(b, 16) for b in expected.strip().split()]
                    data_to_write = [int(b, 16) for b in write_data.strip().split()] if write_data else []

                    logging.info(f"{tc_id} - {step_desc}: SID={service}, Sub={subfunc}, Expected={expected_bytes}")

                    response = None

                    # Send UDS request
                    if service_int == 0x10:
                        raw_request = bytes([0x10, subfunc_int])
                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                    elif service_int == 0x11:
                        raw_request = bytes([0x11, subfunc_int])
                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                    elif service_int == 0x22:
                        did_hi = (subfunc_int >> 8) & 0xFF
                        did_lo = subfunc_int & 0xFF
                        raw_request = bytes([0x22, did_hi, did_lo])
                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                    elif service_int == 0x2E:
                        if not data_to_write:
                            raise ValueError(f"No write data provided in testcase for DID {hex(subfunc_int)}")

                        did_hi = (subfunc_int >> 8) & 0xFF
                        did_lo = subfunc_int & 0xFF
                        raw_request = bytes([0x2E, did_hi, did_lo] + data_to_write)

                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                        raw_payload = list(response)
                        logging.debug(f"{tc_id} {step_desc} -> Received payload: {raw_payload}")

                        if raw_payload[0] != 0x6E or raw_payload[1] != did_hi or raw_payload[2] != did_lo:
                            failure_reason = f"NRC (WriteDataByIdentifier): {raw_payload}"
                            logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                            raise Exception(failure_reason)

                    elif service_int == 0x19:
                        status_mask = 0xFF
                        raw_request = bytes([0x19, subfunc_int, status_mask])
                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                    elif service_int == 0x14:
                        dtc_group_bytes = [(subfunc_int >> shift) & 0xFF for shift in (16, 8, 0)]
                        raw_request = bytes([0x14] + dtc_group_bytes)
                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                    elif service_int == 0x3E:
                        raw_request = bytes([0x3E, 0x00])
                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                    elif service_int == 0x85:
                        raw_request = bytes([0x85, subfunc_int])
                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                    elif service_int == 0x27:

                        if subfunc_int % 2 == 1:  # requestSeed
                            raw_request = bytes([0x27, subfunc_int])
                            client.conn.send(raw_request)
                            response = client.conn.wait_frame(timeout=2)

                            raw_payload = list(response)
                            logging.debug(f"{tc_id} {step_desc} -> Received payload: {raw_payload}")

                            if raw_payload[0] != 0x67 or raw_payload[1] != subfunc_int:
                                failure_reason = f"NRC (seed): {raw_payload}"
                                logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                                raise Exception(failure_reason)

                            seed = bytes(raw_payload[2:])
                            self.context[f"seed_{subfunc_int}"] = seed
                            logging.info(f"Received Seed (subfunc {hex(subfunc_int)}): {seed.hex()}")
                            time.sleep(0.5)

                            # Send seed to PC and get key
                            udp_ip = "192.168.10.220"
                            udp_port = 5005
                            max_retries = 3
                            retry_delay = 1.0
                            expected_key_length = 8

                            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                            sock.settimeout(5)

                            try:
                                for attempt in range(1, max_retries + 1):
                                    try:
                                        logging.info(f"Attempt {attempt}: Sending seed to PC...")
                                        sock.sendto(seed.hex().encode(), (udp_ip, udp_port))
                                        key, _ = sock.recvfrom(1024)
                                        key = key.strip()

                                        if not key:
                                            raise Exception("Received empty key from PC")
                                        if len(key) != expected_key_length:
                                            raise Exception(f"Invalid key length: expected {expected_key_length}, got {len(key)}")

                                        self.context[f"key_{subfunc_int + 1}"] = key
                                        logging.info(f"Received Key (for subfunc {hex(subfunc_int + 1)}): {key}")
                                        break

                                    except socket.timeout:
                                        logging.warning(f"Attempt {attempt} - Timeout waiting for key.")
                                        if attempt < max_retries:
                                            time.sleep(retry_delay)
                                        else:
                                            raise Exception(f"Timeout after {max_retries} retries waiting for key from PC")

                                    except Exception as e:
                                        logging.exception(f"Attempt {attempt} - Error occurred:")
                                        if attempt == max_retries:
                                            raise
                            finally:
                                sock.close()

                        elif subfunc_int % 2 == 0:  # sendKey

                            key = self.context.get(f"key_{subfunc_int}")
                            if not key:
                                raise Exception(f"No key available for subfunction {hex(subfunc_int)}. Ensure seed request precedes key send.")

                            raw_request = bytes([0x27, subfunc_int]) + key
                            client.conn.send(raw_request)
                            response = client.conn.wait_frame(timeout=2)

                            raw_payload = list(response)
                            logging.debug(f"{tc_id} {step_desc} -> Received payload: {raw_payload}")

                            if raw_payload[0] != 0x67 or raw_payload[1] != subfunc_int:
                                failure_reason = f"NRC (key): {raw_payload}"
                                logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                                raise Exception(failure_reason)

                        else:
                            raise ValueError(f"Unsupported subfunction for service 0x27: {hex(subfunc_int)}")

                    elif service_int == 0x28:
                        communication_type = 0x00
                        raw_request = bytes([0x28, subfunc_int, communication_type])
                        client.conn.send(raw_request)
                        response = client.conn.wait_frame(timeout=2)

                    else:
                        raise ValueError(f"Unsupported service: {service}")

                    # === Response Verification ===
                    if response is not None:

                        try:
                            raw_payload = list(response)
                            logging.debug(f"{tc_id} {step_desc} -> Received payload: {raw_payload}")

                            status, failure_reason = self.verify_response(raw_payload, expected_bytes, tc_id, step_desc)

                            if status == "Pass":
                                logging.info(f"{tc_id} {step_desc} -> PASS")
                            else:
                                logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")

                        except Exception as e:
                            status = "Fail"
                            failure_reason = f"Could not extract payload: {str(e)}"
                            logging.error(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                    else:
                        status = "Fail"
                        failure_reason = "No response received (timeout)"
                        logging.error(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")

            except Exception as e:
                status = "Fail"
                failure_reason = str(e)
                logging.error(f"{tc_id} {step_desc} -> EXCEPTION - {failure_reason}")

            delay_key = service.upper()
            delay = float(self.step_delays.get(delay_key, self.default_delay))
            oled.display_centered_text(f"{tc_id}\n{step_desc[:20]}\n{status}")
            time.sleep(delay)

    self.stop_logging()
    time.sleep(1.5)






